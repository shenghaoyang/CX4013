"""
bookingtable.py

Implementation of a timetabling system used to record bookings across
a single week.
"""


import datetime
import sqlite3
from pathlib import Path
from typing import Final, Type
from dataclasses import dataclass


# Reference timezone: UTC.
TIMEZONE: Final = datetime.timezone(datetime.timedelta(0))
# Date of the first day in the timetabling system.
# Used to convert the monday-relative dates to actual datetimes.
START_DATE: Final = datetime.datetime(2021, 3, 15, tzinfo=TIMEZONE)
MAX_TIME: Final = int(datetime.timedelta(days=7).total_seconds())
MAX_DATE: Final = START_DATE + datetime.timedelta(days=7)


@dataclass(frozen=True)
class TimeRange:
    """
    Booking time range.

    Both start and end times are specified as offsets in seconds from the start
    of the first day of the week.

    The start time is inclusive while the end time is exclusive.
    """

    start: int
    end: int

    def __post_init__(self):
        self._validate()

    def _validate(self):
        """
        Validate this time range.

        The time range is considered valid if:

            - The start time is before the end time, AND
            - The start time falls in the range ``[0, MAX_TIME)``, AND
            - The end time falls in the range ``(0, MAX_TIME]``.

        :raises ValueError: on an invalid time range.
        """
        if (
            (not (0 <= self.start < MAX_TIME))
            or (not (0 < self.end <= MAX_TIME))
            or (not (self.start < self.end))
        ):
            raise ValueError("invalid")

    def as_dtrange(self) -> "DateTimeRange":
        """
        Represent this time range as a ``DateTimeRange``.
        """
        return DateTimeRange(
            *tuple(
                map(
                    lambda t: START_DATE + datetime.timedelta(seconds=t),
                    (self.start, self.end),
                )
            )
        )


@dataclass(frozen=True)
class DateTimeRange:
    """
    Booking time range.

    Uses ``datetime.datetime`` instances to represent start and end
    times instead of integers.

    These instances are generated by adding the start / end offsets
    in seconds to ``START_DATE``.

    The absolute datetimes bear no meaning, and these instances are only
    useful for extracting time components (day of week, date,
    hour, etc).

    Has the same half-open semantics as ``TimeRange``.
    """

    start: datetime.datetime
    end: datetime.datetime

    def __post_init__(self):
        self._validate()

    def _validate(self):
        """
        Validate this time range.

        The time range is considered valid if:

            - The start time is before the end time, AND
            - The start time falls in the range ``[START_DATE, MAX_DATE)``, AND
            - The end time falls in the range ``[START_DATE, MAX_DATE]``.

        :raises ValueError: on an invalid time range.
        """
        if (
            (not (START_DATE <= self.start < MAX_DATE))
            or (not (START_DATE < self.end <= MAX_DATE))
            or (not (self.start < self.end))
        ):
            raise ValueError("invalid")

    def as_trange(self) -> TimeRange:
        """
        Represent this time range as a ``TimeRange``
        """
        return TimeRange(
            *tuple(
                map(
                    lambda t: int((t - START_DATE).total_seconds()),
                    (self.start, self.end),
                )
            )
        )


class Table:
    """
    Timetable used to record bookings for certain facilities.
    """

    def __init__(self, path: Path):
        """
        Load an existing timetable from a database file.

        :param path: path to database file.
        """
        self._conn = sqlite3.Connection(path)
        self._allowed_facilities = frozenset(self.facilities())

    @classmethod
    def new(cls: Type["Table"], path: Path, facilities: set[int]) -> "Table":
        """
        Create a new (empty) timetable.

        :param path: path to the database file. It will be erased if it exists, and
            created if it does not exist.
        :param facilities: integer IDs of facilities that can be booked.
        """
        if path.exists():
            path.unlink()

        conn = sqlite3.Connection(path)

        with conn:
            conn.executescript("PRAGMA ENCODING = 'UTF-8';")
            for f in facilities:
                # No injection worries because we constrain names to integers.
                # If the user messes up and passes a string, then it's their fault.
                conn.execute(
                    f"""CREATE TABLE f{f}(
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    start INTEGER UNIQUE NOT NULL,
                    end INTEGER UNIQUE NOT NULL)"""
                )

        conn.close()

        return cls(path)

    def facilities(self) -> set[int]:
        """
        Obtains the facilities available for booking.
        """
        with self._conn:
            cur = self._conn.execute(
                '''SELECT name 
                   FROM sqlite_master 
                   WHERE type = "table"'''
            )

            def res_gen():
                while (t := cur.fetchone()) is not None:
                    if not t[0].startswith("f"):
                        continue
                    yield int(t[0][1:])

            return set(res_gen())

    def list_bookings(self, fid: int) -> list[tuple[int, TimeRange]]:
        """
        Lists the bookings made for a particular facility.

        :param fid: facility id.
        :return: list of ``(id, TimeRange)`` tuples, sorted in order of ascending start time.
        :raises ValueError: if facility ID corresponds to nonexistent facility.
        """
        if fid not in self._allowed_facilities:
            raise ValueError(f"facility {fid} does not exist")

        with self._conn:
            cur = self._conn.execute(
                f"""SELECT *
                    FROM f{fid}
                    ORDER BY start"""
            )

            def res_gen():
                while (t := cur.fetchone()) is not None:
                    yield t[0], TimeRange(*t[1:])

            return list(res_gen())

    def check_avail(self, fid: int, trange: TimeRange) -> bool:
        """
        Check if a particular facility is available for booking.

        :param fid: facility id.
        :param trange: booking time range.
        :return: ``True`` if available, ``False`` otherwise.
        :raises ValueError: if facility ID corresponds to nonexistent facility.
        """
        if fid not in self._allowed_facilities:
            raise ValueError(f"facility {fid} does not exist")

        with self._conn:
            res = self._conn.execute(
                f"""SELECT COUNT(*) 
                   FROM f{fid}
                   WHERE ((start < ?) AND (? < end))""",
                (trange.end, trange.start),
            )
            return not bool(res.fetchone()[0])

    def check_avail_excl(self, fid: int, excl_bid: int, trange: TimeRange) -> bool:
        """
        Check if a particular facility is available for booking, excluding a particular facility-specific booking ID.

        :param fid: facility id.
        :param excl_bid: facility specific booking ID to exclude.
        :param trange: booking time range.
        :return: ``True`` if available, ``False`` otherwise.
        :raises ValueError: if facility ID corresponds to nonexistent facility.
        """
        if fid not in self._allowed_facilities:
            raise ValueError(f"facility {fid} does not exist")

        with self._conn:
            res = self._conn.execute(
                f"""SELECT COUNT(*) 
                   FROM f{fid}
                   WHERE ((start < ?) AND (? < end)) AND
                         (id != ?)""",
                (trange.end, trange.start, excl_bid),
            )
            return not bool(res.fetchone()[0])

    def lookup(self, fid: int, bid: int) -> TimeRange:
        """
        Lookup an existing booking.

        :param fid: facility ID.
        :param bid: facility-specific booking ID.
        :raises ValueError: if facility ID corresponds to nonexistent facility.
        """
        if fid not in self._allowed_facilities:
            raise ValueError(f"facility {fid} does not exist")

        with self._conn:
            cur = self._conn.execute(
                f"""SELECT start, end
                    FROM f{fid}
                    WHERE id = ?""",
                (bid,),
            )

            vals = cur.fetchone()
            if vals is None:
                raise ValueError(f"booking with id {bid} not found for facility {fid}")

            return TimeRange(*vals)

    def book(self, fid: int, trange: TimeRange) -> int:
        """
        Book a facility.

        :param fid: facility id.
        :param trange: booking time range.
        :return: ID of the booking (unique to that facility only).
        :raises ValueError: if facility is not available during ``trange``.
        :raises ValueError: if facility ID corresponds to nonexistent facility.
        """
        if fid not in self._allowed_facilities:
            raise ValueError(f"facility {fid} does not exist")

        # todo do better locking
        if not self.check_avail(fid, trange):
            raise ValueError(f"facility {fid} not available during {trange}")

        with self._conn:
            res = self._conn.execute(
                f"""INSERT INTO f{fid}(start, end) VALUES(?, ?)""",
                (trange.start, trange.end),
            )

            return res.lastrowid

    def modify(self, fid: int, bid: int, trange: TimeRange):
        """
        Modify a booking so that it occupies a new time range.

        :param fid: facility ID.
        :param bid: booking ID.
        :param trange: new time range.
        :raises ValueError: if facility is not available during ``trange``.
        :raises ValueError: if facility ID corresponds to nonexistent facility.
        """
        if fid not in self._allowed_facilities:
            raise ValueError(f"facility {fid} does not exist")

        # todo do better locking
        if not self.check_avail_excl(fid, bid, trange):
            raise ValueError(f"facility {fid} not available during {trange}")

        with self._conn:
            self._conn.execute(
                f"""UPDATE f{fid}
                    SET start = ?, end = ?
                    WHERE id = ?""",
                (trange.start, trange.end, bid),
            )

    def release(self, fid: int, bid: int):
        """
        Release a booking.

        :param fid: facility ID.
        :param bid: booking ID.
        :raises ValueError: if booking with ID does not exist.
        :raises ValueError: if facility ID corresponds to nonexistent facility.
        """
        if fid not in self._allowed_facilities:
            raise ValueError(f"facility {fid} does not exist")

        try:
            self.lookup(fid, bid)
        except ValueError:
            raise ValueError(f"no booking with id {bid} ")

        with self._conn:
            self._conn.execute(
                f"""DELETE
                   FROM f{fid}
                   WHERE id = ?""",
                (bid,),
            )

    def close(self):
        """
        Close the table, releasing the database connection.
        """
        self._conn.close()
