"""
bookingtable.py

Implementation of a timetabling system used to record bookings across
a single week.
"""


import datetime
import sqlite3
from pathlib import Path
from typing import Final, Type, Iterable
from dataclasses import dataclass


# Reference timezone: UTC.
TIMEZONE: Final = datetime.timezone(datetime.timedelta(0))
# Date of the first day in the timetabling system.
# Used to convert the monday-relative dates to actual datetimes.
START_DATE: Final = datetime.datetime(2021, 3, 15, tzinfo=TIMEZONE)
MAX_TIME: Final = int(datetime.timedelta(days=7).total_seconds())
MAX_DATE: Final = START_DATE + datetime.timedelta(days=7)


@dataclass(frozen=True)
class TimeRange:
    """
    Booking time range.

    Both start and end times are specified as offsets in seconds from the start
    of the first day of the week.

    The start time is inclusive while the end time is exclusive.
    """

    start: int
    end: int

    def __post_init__(self):
        self._validate()

    def _validate(self):
        """
        Validate this time range.

        The time range is considered valid if:

            - The start time is before the end time, AND
            - The start time falls in the range ``[0, MAX_TIME)``, AND
            - The end time falls in the range ``(0, MAX_TIME]``.

        :raises ValueError: on an invalid time range.
        """
        if (
            (not (0 <= self.start < MAX_TIME))
            or (not (0 < self.end <= MAX_TIME))
            or (not (self.start < self.end))
        ):
            raise ValueError("invalid")

    def as_dtrange(self) -> "DateTimeRange":
        """
        Represent this time range as a ``DateTimeRange``.
        """
        return DateTimeRange(
            *tuple(
                map(
                    lambda t: START_DATE + datetime.timedelta(seconds=t),
                    (self.start, self.end),
                )
            )
        )


@dataclass(frozen=True)
class DateTimeRange:
    """
    Booking time range.

    Uses ``datetime.datetime`` instances to represent start and end
    times instead of integers.

    These instances are generated by adding the start / end offsets
    in seconds to ``START_DATE``.

    The absolute datetimes bear no meaning, and these instances are only
    useful for extracting time components (day of week, date,
    hour, etc).

    Has the same half-open semantics as ``TimeRange``.
    """

    start: datetime.datetime
    end: datetime.datetime

    def __post_init__(self):
        self._validate()

    def _validate(self):
        """
        Validate this time range.

        The time range is considered valid if:

            - The start time is before the end time, AND
            - The start time falls in the range ``[START_DATE, MAX_DATE)``, AND
            - The end time falls in the range ``[START_DATE, MAX_DATE]``.

        :raises ValueError: on an invalid time range.
        """
        if (
            (not (START_DATE <= self.start < MAX_DATE))
            or (not (START_DATE < self.end <= MAX_DATE))
            or (not (self.start < self.end))
        ):
            raise ValueError("invalid")

    def as_trange(self) -> TimeRange:
        """
        Represent this time range as a ``TimeRange``
        """
        return TimeRange(
            *tuple(
                map(
                    lambda t: int((t - START_DATE).total_seconds()),
                    (self.start, self.end),
                )
            )
        )


class Table:
    """
    Timetable used to record bookings for certain facilities.
    """

    def __init__(self, path: Path):
        """
        Load an existing timetable from a database file.

        :param path: path to database file.
        """
        self._conn = sqlite3.Connection(path)
        self._facilities: dict[str, int] = {}

        self._load_facilities()

    @classmethod
    def new(cls: Type["Table"], path: Path, facilities: set[str]) -> "Table":
        """
        Create a new (empty) timetable.

        :param path: path to the database file. It will be erased if it exists, and
            created if it does not exist.
        :param facilities: facilities that can be booked.
        """
        if path.exists():
            path.unlink()

        conn = sqlite3.Connection(path)

        with conn:
            conn.executescript("PRAGMA ENCODING = 'UTF-8';")

            conn.execute(
                """CREATE TABLE FAC_IDS(
                   id INTEGER PRIMARY KEY,
                   name TEXT UNIQUE)"""
            )

            conn.executemany(
                "INSERT INTO FAC_IDS(id, name) VALUES(?, ?)", enumerate(facilities)
            )

            for i in range(len(facilities)):
                # No injection worries because it's all numbers.
                conn.execute(
                    f"""CREATE TABLE f{i}(
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    start INTEGER UNIQUE NOT NULL,
                    end INTEGER UNIQUE NOT NULL)"""
                )

        conn.close()

        return cls(path)

    def _load_facilities(self):
        """
        Populate the local facilities cache.
        """
        with self._conn:
            cur = self._conn.execute("SELECT * FROM FAC_IDS")

            def res_gen() -> Iterable[tuple[str, int]]:
                while (r := cur.fetchone()) is not None:
                    yield r[1], r[0]

            self._facilities = dict(res_gen())

    def _ensure_facility_exists(self, facility: str):
        """
        Ensure that a named facility exists in the booking database.

        :param facility: facility to check for.
        :raises KeyError: if the facility does not exist.
        """
        if facility not in self._facilities:
            raise KeyError(f"facility {facility} does not exist")

    @property
    def facilities(self) -> set[str]:
        """
        Obtains the facilities available for booking.
        """
        return set(self._facilities)

    def list_bookings(self, facility: str) -> list[tuple[int, TimeRange]]:
        """
        Lists the bookings made for a particular facility.

        :param facility: facility name.
        :return: list of ``(id, TimeRange)`` tuples, sorted in order of ascending start time.
        :raises KeyError: if facility does not exist.
        """
        self._ensure_facility_exists(facility)

        with self._conn:
            cur = self._conn.execute(
                f"""SELECT *
                    FROM f{self._facilities[facility]}
                    ORDER BY start"""
            )

            def res_gen():
                while (t := cur.fetchone()) is not None:
                    yield t[0], TimeRange(*t[1:])

            return list(res_gen())

    def check_avail(self, facility: str, trange: TimeRange) -> bool:
        """
        Check if a particular facility is available for booking.

        :param facility: facility name
        :param trange: booking time range.
        :return: ``True`` if available, ``False`` otherwise.
        :raises KeyError: if facility does not exist.
        """
        self._ensure_facility_exists(facility)

        with self._conn:
            res = self._conn.execute(
                f"""SELECT COUNT(*) 
                   FROM f{self._facilities[facility]}
                   WHERE ((start < ?) AND (? < end))""",
                (trange.end, trange.start),
            )
            return not bool(res.fetchone()[0])

    def check_avail_excl(self, facility: str, excl_bid: int, trange: TimeRange) -> bool:
        """
        Check if a particular facility is available for booking, excluding a particular facility-specific booking ID.

        :param facility: facility name
        :param excl_bid: facility specific booking ID to exclude.
        :param trange: booking time range.
        :return: ``True`` if available, ``False`` otherwise.
        :raises KeyError: if facility does not exist.
        """
        self._ensure_facility_exists(facility)

        with self._conn:
            res = self._conn.execute(
                f"""SELECT COUNT(*) 
                   FROM f{self._facilities[facility]}
                   WHERE ((start < ?) AND (? < end)) AND
                         (id != ?)""",
                (trange.end, trange.start, excl_bid),
            )
            return not bool(res.fetchone()[0])

    def lookup(self, facility: str, bid: int) -> TimeRange:
        """
        Lookup an existing booking.

        :param facility: facility name.
        :param bid: facility-specific booking ID.
        :raises KeyError: if facility does not exist.
        """
        self._ensure_facility_exists(facility)

        with self._conn:
            cur = self._conn.execute(
                f"""SELECT start, end
                    FROM f{self._facilities[facility]}
                    WHERE id = ?""",
                (bid,),
            )

            vals = cur.fetchone()
            if vals is None:
                raise ValueError(f"booking with id {bid} not found for facility {fid}")

            return TimeRange(*vals)

    def book(self, facility: str, trange: TimeRange) -> int:
        """
        Book a facility.

        :param facility: facility name.
        :param trange: booking time range.
        :return: ID of the booking (unique to that facility only).
        :raises ValueError: if facility is not available during ``trange``.
        :raises KeyError: if facility does not exist.
        """
        self._ensure_facility_exists(facility)

        # todo do better locking
        if not self.check_avail(facility, trange):
            raise ValueError(f"facility {facility} not available during {trange}")

        with self._conn:
            res = self._conn.execute(
                f"INSERT INTO f{self._facilities[facility]}(start, end) VALUES(?, ?)",
                (trange.start, trange.end),
            )

            return res.lastrowid

    def modify(self, facility: str, bid: int, trange: TimeRange):
        """
        Modify a booking so that it occupies a new time range.

        :param facility: facility name.
        :param bid: facility-specific booking ID.
        :param trange: new time range.
        :raises ValueError: if facility is not available during ``trange``.
        :raises ValueError: if facility ID corresponds to nonexistent facility.
        """
        self._ensure_facility_exists(facility)

        # todo do better locking
        if not self.check_avail_excl(facility, bid, trange):
            raise ValueError(f"facility {facility} not available during {trange}")

        with self._conn:
            self._conn.execute(
                f"""UPDATE f{self._facilities[facility]}
                    SET start = ?, end = ?
                    WHERE id = ?""",
                (trange.start, trange.end, bid),
            )

    def release(self, facility: str, bid: int):
        """
        Release a booking.

        :param facility: facility name.
        :param bid: booking ID.
        :raises ValueError: if booking with ID does not exist.
        :raises ValueError: if facility ID corresponds to nonexistent facility.
        """
        self._ensure_facility_exists(facility)

        try:
            self.lookup(facility, bid)
        except ValueError:
            raise ValueError(f"no booking with id {bid} exists")

        with self._conn:
            self._conn.execute(
                f"""DELETE
                   FROM f{self._facilities[facility]}
                   WHERE id = ?""",
                (bid,),
            )

    def close(self):
        """
        Close the table, releasing the database connection.
        """
        self._conn.close()
